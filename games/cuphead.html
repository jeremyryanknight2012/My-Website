<!DOCTYPE html>
<html lang="en-us">
<head>
  <base href="https://cdn.jsdelivr.net/gh/web-ports/cuphead@main/">
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL Player | Cuphead</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #231F20;
    }
    #unityContainer {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: #231F20;
    }
    #loading-text {
      position: fixed;
      left: 0;
      right: 0;
      top: 20px;
      text-align: center;
      color: white;
      font-size: 48px;
      font-family: cursive;
      z-index: 9999;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="loading-text">LOADING...</div>
  <div id="unityContainer"></div>

  <script src="Build/UnityLoader.js"></script>
  <script>
    const loadingText = document.getElementById("loading-text");
    const container = document.getElementById("unityContainer");

    let totalBytes = 0;
    let loadedBytes = 0;

    function bytesToMB(bytes) {
      return (bytes / (1024 * 1024)).toFixed(2);
    }

    async function getSize(url) {
      try {
        const res = await fetch(url, { method: "HEAD" });
        const len = res.headers.get("Content-Length");
        return len ? parseInt(len, 10) : 0;
      } catch {
        return 0;
      }
    }

    async function fetchWithProgress(url) {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to fetch ${url} (${response.status})`);
      if (!response.body) throw new Error(`No stream for ${url}`);

      const reader = response.body.getReader();
      const chunks = [];
      let received = 0;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        received += value.length;
        loadedBytes += value.length;
        chunks.push(value);

        // Fix "100/10" overflow by ensuring total >= loaded (HEAD can be wrong/missing on CDNs)
        if (!totalBytes || totalBytes < loadedBytes) totalBytes = loadedBytes;

        loadingText.textContent =
          `LOADING... ${bytesToMB(loadedBytes)} MB / ${bytesToMB(totalBytes)} MB`;
      }

      const buffer = new Uint8Array(received);
      let offset = 0;
      for (const chunk of chunks) {
        buffer.set(chunk, offset);
        offset += chunk.length;
      }
      return buffer.buffer;
    }

    // IMPORTANT: make the returned blob URL *look like* a .unityweb file
    function makeUnitywebBlobUrl(blob) {
      return URL.createObjectURL(blob) + "#.unityweb";
    }

    async function mergeFiles(fileParts) {
      const buffers = await Promise.all(fileParts.map(part => fetchWithProgress(part)));
      const mergedBlob = new Blob(buffers, { type: "application/octet-stream" });
      return makeUnitywebBlobUrl(mergedBlob);
    }

    function getParts(file, start, end) {
      const parts = [];
      for (let i = start; i <= end; i++) parts.push(file + ".part" + i);
      return parts;
    }

    function resizeUnityContainer() {
      container.style.width = window.innerWidth + "px";
      container.style.height = window.innerHeight + "px";
      const canvas = container.querySelector("canvas");
      if (canvas) {
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
      }
    }

    window.addEventListener("resize", resizeUnityContainer);

    (async () => {
      try {
        if (typeof UnityLoader === "undefined") {
          throw new Error("UnityLoader is not defined. Build/UnityLoader.js did not load.");
        }

        const allParts = [
          ...getParts("Build/Build.asm.code.unityweb", 1, 3),
          ...getParts("Build/Build.data.unityweb", 1, 102),
          ...getParts("Build/Build.wasm.code.unityweb", 1, 2),
        ];

        // Best-effort sizing (may be 0 or inaccurate on some CDNs)
        const sizes = await Promise.all(allParts.map(getSize));
        totalBytes = sizes.reduce((a, b) => a + b, 0);

        const [asmurl, dataUrl, wasmurl] = await Promise.all([
          mergeFiles(getParts("Build/Build.asm.code.unityweb", 1, 3)),
          mergeFiles(getParts("Build/Build.data.unityweb", 1, 102)),
          mergeFiles(getParts("Build/Build.wasm.code.unityweb", 1, 2)),
        ]);

        // Keep the config style your repo uses (UnityLoader.instantiate with config object + url param)
        const json = {
          companyName: "SpanishFreddy",
          productName: "Cuphead",

          dataUrl: dataUrl,
          wasmCodeUrl: wasmurl,
          asmCodeUrl: asmurl,

          // FIXED: include Build/ prefix (yours were missing)
          wasmFrameworkUrl: "Build/Build.wasm.framework.unityweb",
          asmMemoryUrl: "Build/Build.asm.memory.unityweb",
          asmFrameworkUrl: "Build/Build.asm.framework.unityweb",

          TOTAL_MEMORY: 100000000,
          graphicsAPI: ["WebGL 2.0", "WebGL 1.0"],
          webglContextAttributes: { preserveDrawingBuffer: false },
          splashScreenStyle: "Dark",
          backgroundColor: "#231F20"
        };

        const blob = new Blob([JSON.stringify(json)], { type: "application/json" });
        const blobUrl = URL.createObjectURL(blob);

        UnityLoader.instantiate("unityContainer", json, {
          url: blobUrl,
          Module: {
            onRuntimeInitialized: function () {
              resizeUnityContainer();
              if (loadingText) loadingText.remove();
            }
          }
        });

        // Keep resizing occasionally (some Unity builds need this)
        (function loopResize() {
          resizeUnityContainer();
          setTimeout(loopResize, 1000);
        })();

      } catch (err) {
        console.error(err);
        loadingText.textContent = "FAILED TO LOAD (check console)";
      }
    })();
  </script>
</body>
</html>
